<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN""http://www.w3.org/TR/REC-html40/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Mon Jun 30 11:47:28 EDT 2003 -->
<TITLE>
SipListener (JAIN-SIP 1.1 RI For the People!)
</TITLE>
<META NAME="keywords" CONTENT="javax.sip.SipListener,SipListener interface">
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<SCRIPT>
function asd()
{
parent.document.title="SipListener (JAIN-SIP 1.1 RI For the People!)";
}
</SCRIPT>
<BODY BGCOLOR="white" onload="asd();">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SipListener.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b> NIST SIP Parser and Stack (v1.2) API </b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/sip/ServerTransaction.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../javax/sip/SipProvider.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SipListener.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.sip</FONT>
<BR>
Interface SipListener</H2>
<DL>
<DT><B>All Superinterfaces:</B> <DD><A HREF="http://java.sun.com/products/j2se/1.4/docs/api/java/util/EventListener.html">EventListener</A></DD>
</DL>
<HR>
<DL>
<DT>public interface <B>SipListener</B><DT>extends <A HREF="http://java.sun.com/products/j2se/1.4/docs/api/java/util/EventListener.html">EventListener</A></DL>

<P>
This interface represents the application view to a SIP stack
 therefore defines the application's communication channel to the SIP stack. 
 This interface defines the methods required by an applications to receive 
 and process Events that are emitted by an object implementing the 
 <A HREF="../../javax/sip/SipProvider.html"><CODE>SipProvider</CODE></A> interface. 
 <p>
 The Events accepted by a SipListener may be one of three types:
 <ul>
 <li> <A HREF="../../javax/sip/RequestEvent.html"><CODE>RequestEvent</CODE></A> - these are request messages emitted
 as events by the SipProvider. Request events represent 
 request messages i.e. INVITE, that are received from the network to the 
 application via the underlying stack implementation.
 <li> <A HREF="../../javax/sip/ResponseEvent.html"><CODE>ResponseEvent</CODE></A> - these are response messages emitted
 as events by the SipProvider. Response events represent 
 Response messages i.e. 2XX's, that are received from the network to the 
 application via the underlying stack implementation.
 <li> <A HREF="../../javax/sip/TimeoutEvent.html"><CODE>TimeoutEvent</CODE></A> - these are timeout notifications
 emitted as events by the SipProvider. Timeout events represent
 timers expiring in the underlying SipProvider transaction state machine. 
 These timeout's events notify the application that a retranmission is 
 required or a transaction has timed out.
 </ul>
 <p>
 An application will only receive Request, Response and Timeout
 events once it has registered as an EventListener of a SipProvider.
 The application registers with the SipProvider by invoking the
 <A HREF="../../javax/sip/SipProvider.html#addSipListener(javax.sip.SipListener)"><CODE>SipProvider.addSipListener(SipListener)</CODE></A> passing itself as an argument.
 <p>
 <b>Architecture:</b><br>
 This specification mandates a single SipListener per SipStack/per IP Address,  
 and a unicast event model i.e. a SipProvider can only have one SipListener 
 registered with it. This specification allows multiple SipProviders per 
 SipStack and as such a SipListener can register with multiple SipProviders 
 i.e there is a one-to-many relationship between a SipListener and a 
 SipProvider.
 <p>
 Note: An application that implements the SipListener interface, may act as a 
 proxy object and pass all events to higher level core application 
 programming logic that is outside the scope of this specification. For 
 example a SIP Servlet, JAIN SLEE or an EJB SIP implementation can implement 
 the UAS, UAC and Proxy core application respectively in there respective 
 container environments utilizing this specification to talk to the 
 SIP network. 
 <p>
 <b>Messaging Model:</b><br>
 An application can send messages by passing 
 <A HREF="../../javax/sip/message/Request.html"><CODE>Request</CODE></A> and <A HREF="../../javax/sip/message/Response.html"><CODE>Response</CODE></A> 
 messages to that the following object:
 <ul>
 <li>Request and response messages can be sent statelessly via the 
 SipProvider using the sendXXX methods on the <A HREF="../../javax/sip/SipProvider.html"><CODE>SipProvider</CODE></A>.
 <li>Request messages can be sent transaction stateful via the 
 ClientTransaction using the 
 <A HREF="../../javax/sip/ClientTransaction.html#sendRequest()"><CODE>ClientTransaction.sendRequest()</CODE></A> method.
 <li>Response messages can be sent transaction stateful via the 
 ServerTransaction using the 
 <A HREF="../../javax/sip/ServerTransaction.html#sendResponse(javax.sip.message.Response)"><CODE>ServerTransaction.sendResponse(Response)</CODE></A> method.
 <li>Request messages can be sent dialog stateful via the 
 Dialog using the 
 <A HREF="../../javax/sip/Dialog.html#sendRequest(javax.sip.ClientTransaction)"><CODE>Dialog.sendRequest(ClientTransaction)</CODE></A> method.
 </ul> 
 Although this specification provides the capabilities to send messages both 
 statelessly and statefully it is mandated that an application will not send 
 the same message both statefully and statelessly.<br>
 The messages sent by the application are not Event's as the event model is 
 uni-directional from the SipProvider to the SipListener, i.e. the 
 SipListener listens for Events from the SipProvider, but the SipProvider does 
 not listen for Events on the SipListener. The rationale is the application 
 knows when to initiate requests and responses i.e setup a call or respond to
 a network event, however an application doesn't know when it will receive a 
 network event, hence the application must listen for these network events. 
 The traditional way to do this in Java is the Java event model.
 <p>
 <b>Session Negotiation</b><br>
 There are special rules for message bodies of Request and Responses that
 contain a session description. SIP uses an offer/answer model where one User 
 Agent sends a session description, called the offer, which contains a proposed
 description of the session. The other User Agent responds with another session 
 description, called the answer, which indicates which communications means 
 are accepted. In this specification, offers and answers can only appear in 
 INVITE requests and Responses, and ACK. The Session Description Protocol (SDP) 
 <a href = "http://www.ietf.org/rfc/rfc2327.txt">RFC2327</a> MUST be
 supported by all user agents as a means to describe sessions, and its usage
 for constructing offers and answers MUST follow the procedures defined in
 <a href = "http://www.ietf.org/rfc/rfc3261.txt">RFC3261</a>. The SDP protocol
 is described in Java by 
 <a href = "http://www.jcp.org/en/jsr/detail?id=141">JSR 141</a>
<P>

<P>
<DL>
<DT><B>Version:</B></DT>
  <DD>1.1</DD>
<DT><B>Author:</B></DT>
  <DD>Sun Microsystems</DD>
<DT><B>See Also:</B><DD><A HREF="../../javax/sip/SipProvider.html"><CODE>SipProvider</CODE></A>, 
<A HREF="../../javax/sip/RequestEvent.html"><CODE>RequestEvent</CODE></A>, 
<A HREF="../../javax/sip/ResponseEvent.html"><CODE>ResponseEvent</CODE></A>, 
<A HREF="../../javax/sip/TimeoutEvent.html"><CODE>TimeoutEvent</CODE></A></DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/sip/SipListener.html#processRequest(javax.sip.RequestEvent)">processRequest</A></B>(<A HREF="../../javax/sip/RequestEvent.html">RequestEvent</A>&nbsp;requestEvent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Processes a Request received on a SipProvider upon which this SipListener
 is registered.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/sip/SipListener.html#processResponse(javax.sip.ResponseEvent)">processResponse</A></B>(<A HREF="../../javax/sip/ResponseEvent.html">ResponseEvent</A>&nbsp;responseEvent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Processes a Response received on a SipProvider upon which this
 SipListener is registered.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/sip/SipListener.html#processTimeout(javax.sip.TimeoutEvent)">processTimeout</A></B>(<A HREF="../../javax/sip/TimeoutEvent.html">TimeoutEvent</A>&nbsp;timeoutEvent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Processes a retransmit or expiration Timeout of an underlying 
 <A HREF="../../javax/sip/Transaction.html"><CODE>Transaction</CODE></A> handled by this SipListener. </TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="processRequest(javax.sip.RequestEvent)"><!-- --></A><H3>
processRequest</H3>
<PRE>
public void <B>processRequest</B>(<A HREF="../../javax/sip/RequestEvent.html">RequestEvent</A>&nbsp;requestEvent)</PRE>
<DL>
<DD>Processes a Request received on a SipProvider upon which this SipListener
 is registered.
 <p>
 <b>Handling Requests:</b><br>
 When the application receives a RequestEvent from the SipProvider the 
 RequestEvent may or may not belong to an existing dialog of the application. 
 The application can be determine if the RequestEvent belongs to an 
 existing dialog by checking the server transaction of the RequestEvent.
 <ul>
 <li>If the server transaction equals <code>null</code> the RequestEvent does 
 not belong to an existing dialog and the application must determine how 
 to handle the RequestEvent. If the application decides to forward the 
 Request statelessly no transactional support is required and it can simply 
 pass the Request of the RequestEvent as an argument to the 
 <A HREF="../../javax/sip/SipProvider.html#sendRequest(javax.sip.message.Request)"><CODE>SipProvider.sendRequest(Request)</CODE></A> method. However if the 
 application determines to respond to a Request statefully it must request
 a new server transaction from the 
 <A HREF="../../javax/sip/SipProvider.html#getNewServerTransaction(javax.sip.message.Request)"><CODE>SipProvider.getNewServerTransaction(Request)</CODE></A> method and use this 
 server transaction to send the Response based on the content of the Request.
 If the SipProvider throws TransactionAlreadyExistsException when the 
 application requests a new server transaction to handle a Request the 
 current RequestEvent is a retransmission of the initial request from which
 the application hadn't requested a server transaction to handle it, i.e. 
 this exception handles the race condition of an application informing the 
 SipProvider that it will handle a Request and the receipt of a 
 retransmission of the Request from the network to the SipProvider.
 <li>If the server transaction <b>does NOT</b> equal <code>null</code> the 
 application determines its action to the RequestEvent based on the 
 content of the Request information.
 </ul>
 <p>
 <b>User Agent Server (UAS) Behaviour:</b><br>
 A UAS application decides whether to accept the an invitation from a 
 UAC. The UAS application can accept the invitation by sending a 2xx 
 response to the UAC, a 2xx response to an INVITE transaction establishes 
 a session. For 2xx responses, the processing is done by the UAS 
 application, to guarantee the three way handshake of an INVITE 
 transaction. This specification defines a utility thats enables the 
 SipProvider to handle the 2XX processing for an INVITE transaction, see 
 the <A HREF="../../javax/sip/SipStack.html#isRetransmissionFilterActive()"><CODE>SipStack.isRetransmissionFilterActive()</CODE></A> method. If the 
 invitation is not accepted, a 3xx, 4xx, 5xx or 6xx response is sent by 
 the application, depending on the reason for 
 the rejection. Alternatively before sending a final response, the UAS 
 can also send provisional responses (1xx) to advise the UAC of progress 
 in contacting the called user. A UAS that receives a CANCEL request for 
 an INVITE, but has not yet sent a final response, would "stop ringing" 
 and then respond to the INVITE with a specific 487 Error response.
 <p>
 <b>General Proxy behaviour:</b><br>
 In some circumstances, a proxy application MAY forward requests using
 stateful transports without being transaction stateful,
 i.e. using the <A HREF="../../javax/sip/SipProvider.html#sendRequest(javax.sip.message.Request)"><CODE>SipProvider.sendRequest(Request)</CODE></A> method,
 but using TCP as a transport.  For example, a proxy application MAY
 forward a request from one TCP connection to another transaction
 statelessly as long as it places enough information in the message to be
 able to forward the response down the same connection the request arrived
 on. This is the responsibility of the application and not the SipProvider.
 Requests forwarded between different types of transports where the
 proxy application takes an active role in ensuring reliable delivery on
 one of the transports must be forwarded using the stateful send methods
 on the SipProvider.
 <p>
 <b>Stateful Proxies:</b><br>
 A stateful proxy MUST create a new server transaction for each new
 request received, either automatically generated by the SipProvider,
 if the request matches an existing dialog or by the an
 application call on the SipProvider if it decides to respond to the
 request statefully. The proxy application determines where to
 route the request, choosing one or more next-hop locations. An outgoing
 request for each next-hop location is processed by its own associated
 client transaction.  The proxy application collects the responses from
 the client transactions and uses them to send responses to the server
 transaction. When an application receives a CANCEL request that matches 
 a server transaction, a stateful proxy cancels any pending client 
 transactions associated with a response context. A stateful proxy 
 responds to the CANCEL rather than simply forwarding a response it would 
 receive from a downstream element.
 <p>
 For all new Requests, including any with unknown methods, an element
 intending to stateful proxy the Request determines the target(s) of the
 request. A stateful proxy MAY process the targets in any order. 
 A stateful proxy must have a mechanism to maintain the target set as 
 responses are received and associate the responses to each forwarded 
 request with the original request. For each target, the proxy forwards 
 the request following these steps:
 <ul>
 <li>Make a copy of the received request.
 <li>Update the Request-URI.
 <li>Update the Max-Forwards header.
 <li>Optionally add a Record-route header.
 <li>Optionally add additional headers.
 <li>Postprocess routing information.
 <li>Determine the next-hop address, port, and transport.
 <li>Add a Via header.
 <li>Add a Content-Length header if necessary.
 <li>Forward the new request using the 
 <A HREF="../../javax/sip/ClientTransaction.html#sendRequest()"><CODE>ClientTransaction.sendRequest()</CODE></A> method.
 <li>Process all responses recieved on the 
 <A HREF="../../javax/sip/SipListener.html#processResponse(javax.sip.ResponseEvent)"><CODE>processResponse(ResponseEvent)</CODE></A> method.
 <li>NOT generate 100 (Trying) responses to non-INVITE requests.
 </ul>
 <p>
 A stateful proxy MAY transition to stateless operation at any time
 during the processing of a request, as long as it did nothing that 
 would prevent it from being stateless initially i.e. forking or 
 generation of a 100 response. When performing such a transition, any 
 state already stored is simply discarded.
 <p>
 <b>Forking Requests:</b><br>
 A stateful proxy application MAY choose to "fork" a request, routing it
 to multiple destinations. Any request that is forwarded to more than
 one location MUST be forwarded using the stateful send methods on the
 SipProvider.
 <p>
 <b>Stateless Proxies:</b><br>
 As a stateless proxy does not have any notion of a transaction, or of
 the response context used to describe stateful proxy behavior,
 <code>requestEvent.getServerTransaction() == null;</code>
 always return <var>true</var>. The transaction layer of the SipProvider
 implementation is by-passed.  For all requests including any with
 unknown methods, an application intending to stateless proxy the request
 MUST:
 <ul>
 <li>Validate the request.
 <li>Preprocess routing information.
 <li>Determine a single target(s) for the request.
 <li>Forward the request to the target using the 
 <A HREF="../../javax/sip/SipProvider.html#sendRequest(javax.sip.message.Request)"><CODE>SipProvider.sendRequest(Request)</CODE></A> method.
 <li>NOT perform special processing for CANCEL requests.
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>requestEvent</CODE> - - requestEvent fired from the SipProvider to
 the SipListener representing a Request received from the network.<DT><B>Since:</B></DT>
  <DD>v1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="processResponse(javax.sip.ResponseEvent)"><!-- --></A><H3>
processResponse</H3>
<PRE>
public void <B>processResponse</B>(<A HREF="../../javax/sip/ResponseEvent.html">ResponseEvent</A>&nbsp;responseEvent)</PRE>
<DL>
<DD>Processes a Response received on a SipProvider upon which this
 SipListener is registered.
 <p>
 <b>Handling Responses:</b><br>
 When the application receives a ResponseEvent from the SipProvider the 
 ResponseEvent may or may not correlate to an existing Request of the 
 application. The application can be determine if the ResponseEvent belongs 
 to an existing Request by checking the client transaction of the 
 ResponseEvent.
 <ul>
 <li>If the the client transaction equals <code>null</code> the 
 ResponseEvent does not belong to an existing Request and the Response is
 considered stray, i.e. stray response can be identitied, if 
 <code>responseEvent.getClientTransaction() == null;</code>. Handling of 
 these "stray" responses is dependent on the application i.e. a proxy will 
 forward them statelessly using the 
 <A HREF="../../javax/sip/SipProvider.html#sendResponse(javax.sip.message.Response)"><CODE>SipProvider.sendResponse(Response)</CODE></A> method, while a User 
 Agent will discard them. 
 <li>If the client transaction <b>does NOT</b> equal <code>null</code> the 
 application determines it action to the ResponseEvent based on the 
 content of the Response information.
 </ul>
 <p>
 <b>User Agent Client (UAC) behaviour:</b><br>
 After possibly receiving one or more provisional responses (1xx) to a
 Request, the UAC will get one or more 2xx responses or one non-2xx final 
 response. Because of the protracted amount of time it can take to receive 
 final responses to an INVITE, the reliability mechanisms for INVITE 
 transactions differ from those of other requests.
 A UAC needs to send an ACK for every final Response it receives, however 
 the procedure for sending the ACK depends on the type of Response. For 
 final responses between 300 and 699, the ACK processing is done by the 
 transaction layer i.e. handled by the implementation. For 2xx responses, the 
 ACK processing is done by the UAC application, to guarantee the three way 
 handshake of an INVITE transaction. This specification defines a utility 
 thats enables the SipProvider to handle the ACK processing for an INVITE
 transaction, see the <A HREF="../../javax/sip/SipStack.html#isRetransmissionFilterActive()"><CODE>SipStack.isRetransmissionFilterActive()</CODE></A> method.
 <br> 
 A 2xx response to an INVITE establishes a session, and it also
 creates a dialog between the UAC that issued the INVITE and the UAS 
 that generated the 2xx response. Therefore, when multiple 2xx responses 
 are received from different remote User Agents, i.e. the INVITE forked, 
 each 2xx establishes a different dialog and all these dialogs are part of 
 the same call. If an INVITE client transaction returns a <A HREF="../../javax/sip/TimeoutEvent.html"><CODE>TimeoutEvent</CODE></A> 
 rather than a response the UAC acts as if a 408 (Request Timeout) 
 response had been received from the UAS.
 <p>
 <b>Stateful Proxies:</b><br>
 A proxy application that handles a response statefully must do the 
 following processing:
 <ul>
 <li>Find the appropriate response context.
 <li>Remove the topmost Via header.
 <li>Add the response to the response context.
 <li>Check to determine if this response should be forwarded immediately.
 <li>When necessary, choose the best final response from the
 response context. If no final response has been forwarded after every
 client transaction associated with the response context has been
 terminated, the proxy must choose and forward the "best" response
 from those it has seen so far.
 </ul>
 <p>
 Additionally the following processing MUST be performed on each response
 that is forwarded. 
 <ul>
 <li>Aggregate authorization header values if necessary.
 <li>Optionally rewrite Record-Route header values.
 <li>Forward the response using the 
 <A HREF="../../javax/sip/ServerTransaction.html#sendResponse(javax.sip.message.Response)"><CODE>ServerTransaction.sendResponse(Response)</CODE></A> method.
 <li>Generate any necessary CANCEL requests.
 </ul>
 <p>
 <b>Stateless Proxies:</b><br>
 As a stateless proxy does not have any notion of transactions, or of
 the response context used to describe stateful proxy behavior,
 <code>responseEvent.getClientTransaction == null;</code>
 always return <var>true</var>. Response processing does not apply, the
 transaction layer of the SipProvider implementation is by-passed. An
 application intending to stateless proxy the Response MUST:
 <ul>
 <li>Inspect the sent-by value in the first Via header.
 <li>If that address matches the proxy, the proxy MUST remove that header
 from the response.
 <li>Forward the resulting response to the location indicated in the
 next Via header using the 
 <A HREF="../../javax/sip/SipProvider.html#sendResponse(javax.sip.message.Response)"><CODE>SipProvider.sendResponse(Response)</CODE></A> method.
 </ul>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>responseEvent</CODE> - - the responseEvent fired from the SipProvider to
 the SipListener representing a Response received from the network.<DT><B>Since:</B></DT>
  <DD>v1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="processTimeout(javax.sip.TimeoutEvent)"><!-- --></A><H3>
processTimeout</H3>
<PRE>
public void <B>processTimeout</B>(<A HREF="../../javax/sip/TimeoutEvent.html">TimeoutEvent</A>&nbsp;timeoutEvent)</PRE>
<DL>
<DD>Processes a retransmit or expiration Timeout of an underlying 
 <A HREF="../../javax/sip/Transaction.html"><CODE>Transaction</CODE></A> handled by this SipListener. This Event notifies the 
 application that a retransmission or transaction Timer expired in the 
 SipProvider's transaction state machine. The TimeoutEvent encapsulates 
 the specific timeout type and the transaction identifier either client 
 or server upon which the timeout occured. The type of Timeout can by 
 determined by: 
 <code>timeoutType = timeoutEvent.getTimeout().getValue();</code>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>timeoutEvent</CODE> - - the timeoutEvent received indicating either the
 message retransmit or transaction timed out.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/SipListener.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b> NIST SIP Parser and Stack (v1.2) API </b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../javax/sip/ServerTransaction.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../javax/sip/SipProvider.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="SipListener.html" TARGET="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;
<SCRIPT>
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
<A HREF="../../allclasses-noframe.html" TARGET=""><B>All Classes</B></A>
</NOSCRIPT>
</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<font size="-1"> <a href="http://www-x.antd.nist.gov/"> A product of the NIST/ITL Advanced Networking Technologies Division. </a><br> <a href="../../uncopyright.html"> See conditions of use. </a> <br> <a href="http://www-x.antd.nist.gov/proj/iptel/nist-sip-requestform/nist-sip-1.2-requestform.htm"> Get the latest distribution. </a><br> <a href="mailto:nist-sip-dev@antd.nist.gov">Submit a bug report or feature request. </a><br> </font>
</BODY>
</HTML>
